"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@ag-ui/core");
const react_1 = require("@testing-library/react");
const react_2 = __importDefault(require("react"));
const tambo_v1_stream_context_1 = require("./tambo-v1-stream-context");
describe("TamboV1StreamProvider", () => {
    describe("useStreamState", () => {
        it("throws when used outside provider", () => {
            // Suppress console.error for expected error
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)());
            }).toThrow("useStreamState must be used within TamboV1StreamProvider");
            consoleSpy.mockRestore();
        });
        it("returns initial state with empty threadMap when no threadId", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, null, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)(), { wrapper });
            expect(result.current.threadMap).toEqual({});
            expect(result.current.currentThreadId).toBeNull();
        });
        it("initializes thread when threadId is provided", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, { threadId: "thread_123" }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)(), { wrapper });
            expect(result.current.currentThreadId).toBe("thread_123");
            expect(result.current.threadMap.thread_123).toBeDefined();
            expect(result.current.threadMap.thread_123.thread.id).toBe("thread_123");
            expect(result.current.threadMap.thread_123.thread.status).toBe("idle");
            expect(result.current.threadMap.thread_123.thread.messages).toEqual([]);
        });
        it("merges initialThread with default state", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, { threadId: "thread_123", initialThread: {
                    title: "Test Thread",
                    metadata: { key: "value" },
                } }, children));
            const { result } = (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamState)(), { wrapper });
            expect(result.current.threadMap.thread_123.thread.title).toBe("Test Thread");
            expect(result.current.threadMap.thread_123.thread.metadata).toEqual({
                key: "value",
            });
            // Default values should still be set
            expect(result.current.threadMap.thread_123.thread.status).toBe("idle");
        });
    });
    describe("useStreamDispatch", () => {
        it("throws when used outside provider", () => {
            const consoleSpy = jest
                .spyOn(console, "error")
                .mockImplementation(() => { });
            expect(() => {
                (0, react_1.renderHook)(() => (0, tambo_v1_stream_context_1.useStreamDispatch)());
            }).toThrow("useStreamDispatch must be used within TamboV1StreamProvider");
            consoleSpy.mockRestore();
        });
        it("dispatches events to update state", () => {
            const wrapper = ({ children }) => (react_2.default.createElement(tambo_v1_stream_context_1.TamboV1StreamProvider, { threadId: "thread_123" }, children));
            const { result } = (0, react_1.renderHook)(() => ({
                state: (0, tambo_v1_stream_context_1.useStreamState)(),
                dispatch: (0, tambo_v1_stream_context_1.useStreamDispatch)(),
            }), { wrapper });
            const runStartedEvent = {
                type: core_1.EventType.RUN_STARTED,
                runId: "run_1",
                threadId: "thread_123",
            };
            (0, react_1.act)(() => {
                result.current.dispatch({
                    type: "EVENT",
                    event: runStartedEvent,
                    threadId: "thread_123",
                });
            });
            expect(result.current.state.threadMap.thread_123.thread.status).toBe("streaming");
            expect(result.current.state.threadMap.thread_123.streaming.status).toBe("streaming");
            expect(result.current.state.threadMap.thread_123.streaming.runId).toBe("run_1");
        });
    });
});
//# sourceMappingURL=tambo-v1-stream-context.test.js.map