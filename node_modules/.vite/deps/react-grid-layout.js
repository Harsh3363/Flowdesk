import {
  GridItem,
  GridLayout,
  ResponsiveGridLayout,
  bottom,
  calcGridItemPosition,
  calcWH,
  calcXY,
  cloneLayout,
  cloneLayoutItem,
  collides,
  correctBounds,
  deepEqual,
  findOrGenerateResponsiveLayout,
  getAllCollisions,
  getBreakpointFromWidth,
  getColsFromBreakpoint,
  getCompactor,
  getFirstCollision,
  getLayoutItem,
  horizontalCompactor,
  moveElement,
  noCompactor,
  setTopLeft,
  setTransform,
  sortBreakpoints,
  sortLayoutItems,
  sortLayoutItemsByColRow,
  sortLayoutItemsByRowCol,
  validateLayout,
  verticalCompactor
} from "./chunk-QX5EKZXF.js";
import "./chunk-CRNJR6QK.js";
import "./chunk-VEB3A3D5.js";
import "./chunk-NHY3NUFE.js";
import "./chunk-276SZO74.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/react-grid-layout/dist/chunk-YFVX5RDK.mjs
var import_react = __toESM(require_react(), 1);
function useContainerWidth(options = {}) {
  const { measureBeforeMount = false, initialWidth = 1280 } = options;
  const [width, setWidth] = (0, import_react.useState)(initialWidth);
  const [mounted, setMounted] = (0, import_react.useState)(!measureBeforeMount);
  const containerRef = (0, import_react.useRef)(null);
  const observerRef = (0, import_react.useRef)(null);
  const measureWidth = (0, import_react.useCallback)(() => {
    const node = containerRef.current;
    if (node) {
      const newWidth = node.offsetWidth;
      setWidth(newWidth);
      if (!mounted) {
        setMounted(true);
      }
    }
  }, [mounted]);
  (0, import_react.useEffect)(() => {
    const node = containerRef.current;
    if (!node) return;
    measureWidth();
    if (typeof ResizeObserver !== "undefined") {
      observerRef.current = new ResizeObserver((entries) => {
        const entry = entries[0];
        if (entry) {
          const newWidth = entry.contentRect.width;
          setWidth(newWidth);
        }
      });
      observerRef.current.observe(node);
    }
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
    };
  }, [measureWidth]);
  return {
    width,
    mounted,
    containerRef,
    measureWidth
  };
}
function useGridLayout(options) {
  const {
    layout: propsLayout,
    cols,
    preventCollision = false,
    onLayoutChange,
    compactor = verticalCompactor
  } = options;
  const isDraggingRef = (0, import_react.useRef)(false);
  const [layout, setLayoutState] = (0, import_react.useState)(() => {
    const corrected = correctBounds(cloneLayout(propsLayout), { cols });
    return compactor.compact(corrected, cols);
  });
  const [dragState, setDragState] = (0, import_react.useState)({
    activeDrag: null,
    oldDragItem: null,
    oldLayout: null
  });
  const [resizeState, setResizeState] = (0, import_react.useState)({
    resizing: false,
    oldResizeItem: null,
    oldLayout: null
  });
  const [dropState, setDropState] = (0, import_react.useState)({
    droppingDOMNode: null,
    droppingPosition: null
  });
  const prevLayoutRef = (0, import_react.useRef)(layout);
  const setLayout = (0, import_react.useCallback)(
    (newLayout) => {
      const corrected = correctBounds(cloneLayout(newLayout), { cols });
      const compacted = compactor.compact(corrected, cols);
      setLayoutState(compacted);
    },
    [cols, compactor]
  );
  (0, import_react.useEffect)(() => {
    if (isDraggingRef.current) return;
    if (!deepEqual(propsLayout, prevLayoutRef.current)) {
      setLayout(propsLayout);
    }
  }, [propsLayout, setLayout]);
  (0, import_react.useEffect)(() => {
    if (!deepEqual(layout, prevLayoutRef.current)) {
      prevLayoutRef.current = layout;
      onLayoutChange == null ? void 0 : onLayoutChange(layout);
    }
  }, [layout, onLayoutChange]);
  const onDragStart = (0, import_react.useCallback)(
    (itemId, x, y) => {
      const item = getLayoutItem(layout, itemId);
      if (!item) return null;
      isDraggingRef.current = true;
      const placeholder = {
        ...cloneLayoutItem(item),
        x,
        y,
        static: false,
        moved: false
      };
      setDragState({
        activeDrag: placeholder,
        oldDragItem: cloneLayoutItem(item),
        oldLayout: cloneLayout(layout)
      });
      return placeholder;
    },
    [layout]
  );
  const onDrag = (0, import_react.useCallback)(
    (itemId, x, y) => {
      const item = getLayoutItem(layout, itemId);
      if (!item) return;
      setDragState((prev) => ({
        ...prev,
        activeDrag: prev.activeDrag ? { ...prev.activeDrag, x, y } : null
      }));
      const newLayout = moveElement(
        layout,
        item,
        x,
        y,
        true,
        // isUserAction
        preventCollision,
        compactor.type,
        cols,
        compactor.allowOverlap
      );
      const compacted = compactor.compact(newLayout, cols);
      setLayoutState(compacted);
    },
    [layout, cols, compactor, preventCollision]
  );
  const onDragStop = (0, import_react.useCallback)(
    (itemId, x, y) => {
      const item = getLayoutItem(layout, itemId);
      if (!item) return;
      const newLayout = moveElement(
        layout,
        item,
        x,
        y,
        true,
        preventCollision,
        compactor.type,
        cols,
        compactor.allowOverlap
      );
      const compacted = compactor.compact(newLayout, cols);
      isDraggingRef.current = false;
      setDragState({
        activeDrag: null,
        oldDragItem: null,
        oldLayout: null
      });
      setLayoutState(compacted);
    },
    [layout, cols, compactor, preventCollision]
  );
  const onResizeStart = (0, import_react.useCallback)(
    (itemId) => {
      const item = getLayoutItem(layout, itemId);
      if (!item) return null;
      setResizeState({
        resizing: true,
        oldResizeItem: cloneLayoutItem(item),
        oldLayout: cloneLayout(layout)
      });
      return item;
    },
    [layout]
  );
  const onResize = (0, import_react.useCallback)(
    (itemId, w, h, x, y) => {
      const newLayout = layout.map((item) => {
        if (item.i === itemId) {
          const updated = {
            ...item,
            w,
            h
          };
          if (x !== void 0) updated.x = x;
          if (y !== void 0) updated.y = y;
          return updated;
        }
        return item;
      });
      const corrected = correctBounds(newLayout, { cols });
      const compacted = compactor.compact(corrected, cols);
      setLayoutState(compacted);
    },
    [layout, cols, compactor]
  );
  const onResizeStop = (0, import_react.useCallback)(
    (itemId, w, h) => {
      onResize(itemId, w, h);
      setResizeState({
        resizing: false,
        oldResizeItem: null,
        oldLayout: null
      });
    },
    [onResize]
  );
  const onDropDragOver = (0, import_react.useCallback)(
    (droppingItem, position) => {
      const existingItem = getLayoutItem(layout, droppingItem.i);
      if (!existingItem) {
        const newLayout = [...layout, droppingItem];
        const corrected = correctBounds(newLayout, { cols });
        const compacted = compactor.compact(corrected, cols);
        setLayoutState(compacted);
      }
      setDropState({
        droppingDOMNode: null,
        // Will be set by component
        droppingPosition: position
      });
    },
    [layout, cols, compactor]
  );
  const onDropDragLeave = (0, import_react.useCallback)(() => {
    const newLayout = layout.filter((item) => item.i !== "__dropping-elem__");
    setLayoutState(newLayout);
    setDropState({
      droppingDOMNode: null,
      droppingPosition: null
    });
  }, [layout]);
  const onDrop = (0, import_react.useCallback)(
    (droppingItem) => {
      const newLayout = layout.map((item) => {
        if (item.i === "__dropping-elem__") {
          return {
            ...item,
            i: droppingItem.i,
            static: false
          };
        }
        return item;
      });
      const corrected = correctBounds(newLayout, { cols });
      const compacted = compactor.compact(corrected, cols);
      setLayoutState(compacted);
      setDropState({
        droppingDOMNode: null,
        droppingPosition: null
      });
    },
    [layout, cols, compactor]
  );
  const containerHeight = (0, import_react.useMemo)(() => bottom(layout), [layout]);
  const isInteracting = dragState.activeDrag !== null || resizeState.resizing || dropState.droppingPosition !== null;
  return {
    layout,
    setLayout,
    dragState,
    resizeState,
    dropState,
    onDragStart,
    onDrag,
    onDragStop,
    onResizeStart,
    onResize,
    onResizeStop,
    onDropDragOver,
    onDropDragLeave,
    onDrop,
    containerHeight,
    isInteracting,
    compactor
  };
}
var DEFAULT_BREAKPOINTS = {
  lg: 1200,
  md: 996,
  sm: 768,
  xs: 480,
  xxs: 0
};
var DEFAULT_COLS = {
  lg: 12,
  md: 10,
  sm: 6,
  xs: 4,
  xxs: 2
};
function useResponsiveLayout(options) {
  const {
    width,
    breakpoints = DEFAULT_BREAKPOINTS,
    cols: colsConfig = DEFAULT_COLS,
    layouts: propsLayouts = {},
    compactor = verticalCompactor,
    onBreakpointChange,
    onLayoutChange,
    onWidthChange
  } = options;
  const sortedBreakpoints = (0, import_react.useMemo)(
    () => sortBreakpoints(breakpoints),
    [breakpoints]
  );
  const initialBreakpoint = (0, import_react.useMemo)(
    () => getBreakpointFromWidth(breakpoints, width),
    // Only calculate on mount, not on width changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const initialCols = (0, import_react.useMemo)(
    () => getColsFromBreakpoint(initialBreakpoint, colsConfig),
    [initialBreakpoint, colsConfig]
  );
  const [breakpoint, setBreakpoint] = (0, import_react.useState)(initialBreakpoint);
  const [cols, setCols] = (0, import_react.useState)(initialCols);
  const [layouts, setLayoutsState] = (0, import_react.useState)(() => {
    const cloned = {};
    for (const bp of sortedBreakpoints) {
      const layout2 = propsLayouts[bp];
      if (layout2) {
        cloned[bp] = cloneLayout(layout2);
      }
    }
    return cloned;
  });
  const prevWidthRef = (0, import_react.useRef)(width);
  const prevBreakpointRef = (0, import_react.useRef)(breakpoint);
  const prevPropsLayoutsRef = (0, import_react.useRef)(propsLayouts);
  const prevLayoutsRef = (0, import_react.useRef)(layouts);
  const layout = (0, import_react.useMemo)(() => {
    return findOrGenerateResponsiveLayout(
      layouts,
      breakpoints,
      breakpoint,
      prevBreakpointRef.current,
      cols,
      compactor
    );
  }, [layouts, breakpoints, breakpoint, cols, compactor]);
  const setLayoutForBreakpoint = (0, import_react.useCallback)((bp, newLayout) => {
    setLayoutsState((prev) => ({
      ...prev,
      [bp]: cloneLayout(newLayout)
    }));
  }, []);
  const setLayouts = (0, import_react.useCallback)((newLayouts) => {
    const cloned = {};
    for (const bp of Object.keys(newLayouts)) {
      const layoutForBp = newLayouts[bp];
      if (layoutForBp) {
        cloned[bp] = cloneLayout(layoutForBp);
      }
    }
    setLayoutsState(cloned);
  }, []);
  (0, import_react.useEffect)(() => {
    if (prevWidthRef.current === width) return;
    prevWidthRef.current = width;
    const newBreakpoint = getBreakpointFromWidth(breakpoints, width);
    const newCols = getColsFromBreakpoint(newBreakpoint, colsConfig);
    onWidthChange == null ? void 0 : onWidthChange(width, [10, 10], newCols, null);
    if (newBreakpoint !== breakpoint) {
      const newLayout = findOrGenerateResponsiveLayout(
        layouts,
        breakpoints,
        newBreakpoint,
        breakpoint,
        newCols,
        compactor
      );
      const updatedLayouts = {
        ...layouts,
        [newBreakpoint]: newLayout
      };
      setLayoutsState(updatedLayouts);
      setBreakpoint(newBreakpoint);
      setCols(newCols);
      onBreakpointChange == null ? void 0 : onBreakpointChange(newBreakpoint, newCols);
      prevBreakpointRef.current = newBreakpoint;
    }
  }, [
    width,
    breakpoints,
    colsConfig,
    breakpoint,
    layouts,
    compactor,
    onBreakpointChange,
    onWidthChange
  ]);
  (0, import_react.useEffect)(() => {
    if (!deepEqual(propsLayouts, prevPropsLayoutsRef.current)) {
      setLayouts(propsLayouts);
      prevPropsLayoutsRef.current = propsLayouts;
    }
  }, [propsLayouts, setLayouts]);
  (0, import_react.useEffect)(() => {
    if (!deepEqual(layouts, prevLayoutsRef.current)) {
      prevLayoutsRef.current = layouts;
      onLayoutChange == null ? void 0 : onLayoutChange(layout, layouts);
    }
  }, [layout, layouts, onLayoutChange]);
  return {
    layout,
    layouts,
    breakpoint,
    cols,
    setLayoutForBreakpoint,
    setLayouts,
    sortedBreakpoints
  };
}
export {
  DEFAULT_BREAKPOINTS,
  DEFAULT_COLS,
  GridItem,
  GridLayout,
  GridLayout as ReactGridLayout,
  ResponsiveGridLayout as Responsive,
  ResponsiveGridLayout,
  bottom,
  calcGridItemPosition,
  calcWH,
  calcXY,
  cloneLayout,
  cloneLayoutItem,
  collides,
  GridLayout as default,
  findOrGenerateResponsiveLayout,
  getAllCollisions,
  getBreakpointFromWidth,
  getColsFromBreakpoint,
  getCompactor,
  getFirstCollision,
  getLayoutItem,
  horizontalCompactor,
  moveElement,
  noCompactor,
  setTopLeft,
  setTransform,
  sortLayoutItems,
  sortLayoutItemsByColRow,
  sortLayoutItemsByRowCol,
  useContainerWidth,
  useGridLayout,
  useResponsiveLayout,
  validateLayout,
  verticalCompactor
};
//# sourceMappingURL=react-grid-layout.js.map
