{
  "version": 3,
  "sources": ["../../react-grid-layout/src/react/hooks/useContainerWidth.ts", "../../react-grid-layout/src/react/hooks/useGridLayout.ts", "../../react-grid-layout/src/react/hooks/useResponsiveLayout.ts"],
  "sourcesContent": ["/**\n * useContainerWidth hook\n *\n * Observes container width using ResizeObserver and provides\n * reactive width updates for responsive layouts.\n */\n\nimport {\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n  type RefObject\n} from \"react\";\n\nexport interface UseContainerWidthOptions {\n  /**\n   * If true, delays initial render until width is measured.\n   * Useful for SSR or when you need accurate initial measurements.\n   */\n  measureBeforeMount?: boolean;\n\n  /**\n   * Initial width to use before measurement.\n   * Defaults to 1280.\n   */\n  initialWidth?: number;\n}\n\nexport interface UseContainerWidthResult {\n  /**\n   * Current container width in pixels.\n   */\n  width: number;\n\n  /**\n   * Whether the container has been measured at least once.\n   */\n  mounted: boolean;\n\n  /**\n   * Ref to attach to the container element.\n   */\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  /**\n   * Manually trigger a width measurement.\n   * Useful when the container size might change without a resize event.\n   */\n  measureWidth: () => void;\n}\n\n/**\n * Hook to observe and track container width.\n *\n * Replaces the WidthProvider HOC with a more composable approach.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const { width, containerRef, mounted } = useContainerWidth();\n *\n *   return (\n *     <div ref={containerRef}>\n *       {mounted && <GridLayout width={width} {...props} />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useContainerWidth(\n  options: UseContainerWidthOptions = {}\n): UseContainerWidthResult {\n  const { measureBeforeMount = false, initialWidth = 1280 } = options;\n\n  const [width, setWidth] = useState(initialWidth);\n  const [mounted, setMounted] = useState(!measureBeforeMount);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const observerRef = useRef<ResizeObserver | null>(null);\n\n  const measureWidth = useCallback(() => {\n    const node = containerRef.current;\n    if (node) {\n      const newWidth = node.offsetWidth;\n      setWidth(newWidth);\n      if (!mounted) {\n        setMounted(true);\n      }\n    }\n  }, [mounted]);\n\n  useEffect(() => {\n    const node = containerRef.current;\n    if (!node) return;\n\n    // Initial measurement\n    measureWidth();\n\n    // Set up ResizeObserver\n    if (typeof ResizeObserver !== \"undefined\") {\n      observerRef.current = new ResizeObserver(entries => {\n        const entry = entries[0];\n        if (entry) {\n          // Use contentRect.width for consistent measurements\n          const newWidth = entry.contentRect.width;\n          setWidth(newWidth);\n        }\n      });\n\n      observerRef.current.observe(node);\n    }\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n        observerRef.current = null;\n      }\n    };\n  }, [measureWidth]);\n\n  return {\n    width,\n    mounted,\n    containerRef,\n    measureWidth\n  };\n}\n\nexport default useContainerWidth;\n", "/**\n * useGridLayout hook\n *\n * Core hook for managing grid layout state, including drag, resize, and drop operations.\n * This extracts the state management logic from ReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useMemo, useRef, useEffect } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  LayoutItem,\n  DroppingPosition,\n  Compactor,\n  Mutable\n} from \"../../core/types.js\";\nimport {\n  cloneLayout,\n  cloneLayoutItem,\n  moveElement,\n  correctBounds,\n  bottom,\n  getLayoutItem\n} from \"../../core/layout.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface DragState {\n  /** Currently dragging item placeholder */\n  activeDrag: LayoutItem | null;\n  /** Original item before drag started */\n  oldDragItem: LayoutItem | null;\n  /** Layout before drag started */\n  oldLayout: Layout | null;\n}\n\nexport interface ResizeState {\n  /** Whether a resize is in progress */\n  resizing: boolean;\n  /** Original item before resize started */\n  oldResizeItem: LayoutItem | null;\n  /** Layout before resize started */\n  oldLayout: Layout | null;\n}\n\nexport interface DropState {\n  /** DOM node for the dropping placeholder */\n  droppingDOMNode: React.ReactElement | null;\n  /** Current drop position */\n  droppingPosition: DroppingPosition | null;\n}\n\nexport interface UseGridLayoutOptions {\n  /** Initial layout */\n  layout: Layout;\n  /** Number of columns */\n  cols: number;\n  /** Prevent collisions when moving items */\n  preventCollision?: boolean;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout) => void;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n}\n\nexport interface UseGridLayoutResult {\n  /** Current layout */\n  layout: Layout;\n  /** Set layout directly */\n  setLayout: (layout: Layout) => void;\n  /** Drag state */\n  dragState: DragState;\n  /** Resize state */\n  resizeState: ResizeState;\n  /** Drop state */\n  dropState: DropState;\n  /** Start dragging an item */\n  onDragStart: (itemId: string, x: number, y: number) => LayoutItem | null;\n  /** Update drag position */\n  onDrag: (itemId: string, x: number, y: number) => void;\n  /** Stop dragging */\n  onDragStop: (itemId: string, x: number, y: number) => void;\n  /** Start resizing an item */\n  onResizeStart: (itemId: string) => LayoutItem | null;\n  /** Update resize dimensions */\n  onResize: (\n    itemId: string,\n    w: number,\n    h: number,\n    x?: number,\n    y?: number\n  ) => void;\n  /** Stop resizing */\n  onResizeStop: (itemId: string, w: number, h: number) => void;\n  /** Start dropping (external drag-in) */\n  onDropDragOver: (\n    droppingItem: LayoutItem,\n    position: DroppingPosition\n  ) => void;\n  /** Update drop position */\n  onDropDragLeave: () => void;\n  /** Complete drop */\n  onDrop: (droppingItem: LayoutItem) => void;\n  /** Container height in rows */\n  containerHeight: number;\n  /** Whether any drag/resize is active */\n  isInteracting: boolean;\n  /** Get the compactor being used */\n  compactor: Compactor;\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing grid layout state.\n *\n * Handles all layout state including drag, resize, and drop operations.\n * Uses immutable updates and provides callbacks for all interactions.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const {\n *     layout,\n *     onDragStart,\n *     onDrag,\n *     onDragStop,\n *     containerHeight\n *   } = useGridLayout({\n *     layout: initialLayout,\n *     cols: 12\n *   });\n *\n *   return (\n *     <div style={{ height: containerHeight }}>\n *       {layout.map(item => (\n *         <GridItem\n *           key={item.i}\n *           {...item}\n *           onDragStart={() => onDragStart(item.i, item.x, item.y)}\n *         />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useGridLayout(\n  options: UseGridLayoutOptions\n): UseGridLayoutResult {\n  const {\n    layout: propsLayout,\n    cols,\n    preventCollision = false,\n    onLayoutChange,\n    compactor = verticalCompactor\n  } = options;\n\n  // Track if we're currently dragging to block prop updates\n  const isDraggingRef = useRef(false);\n\n  // Initialize layout with compaction using the compactor\n  const [layout, setLayoutState] = useState<Layout>(() => {\n    const corrected = correctBounds(cloneLayout(propsLayout), { cols });\n    return compactor.compact(corrected, cols);\n  });\n\n  // Drag state\n  const [dragState, setDragState] = useState<DragState>({\n    activeDrag: null,\n    oldDragItem: null,\n    oldLayout: null\n  });\n\n  // Resize state\n  const [resizeState, setResizeState] = useState<ResizeState>({\n    resizing: false,\n    oldResizeItem: null,\n    oldLayout: null\n  });\n\n  // Drop state\n  const [dropState, setDropState] = useState<DropState>({\n    droppingDOMNode: null,\n    droppingPosition: null\n  });\n\n  // Track previous layout for change detection\n  const prevLayoutRef = useRef<Layout>(layout);\n\n  // Set layout with optional compaction - use compactor.compact() (#2213)\n  const setLayout = useCallback(\n    (newLayout: Layout) => {\n      const corrected = correctBounds(cloneLayout(newLayout), { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n    },\n    [cols, compactor]\n  );\n\n  // Sync layout from props when not dragging\n  useEffect(() => {\n    if (isDraggingRef.current) return;\n\n    if (!deepEqual(propsLayout, prevLayoutRef.current)) {\n      setLayout(propsLayout);\n    }\n  }, [propsLayout, setLayout]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layout, prevLayoutRef.current)) {\n      prevLayoutRef.current = layout;\n      onLayoutChange?.(layout);\n    }\n  }, [layout, onLayoutChange]);\n\n  // ============================================================================\n  // Drag Handlers\n  // ============================================================================\n\n  const onDragStart = useCallback(\n    (itemId: string, x: number, y: number): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      isDraggingRef.current = true;\n\n      const placeholder: LayoutItem = {\n        ...cloneLayoutItem(item),\n        x,\n        y,\n        static: false,\n        moved: false\n      };\n\n      setDragState({\n        activeDrag: placeholder,\n        oldDragItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return placeholder;\n    },\n    [layout]\n  );\n\n  const onDrag = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Update placeholder position\n      setDragState(prev => ({\n        ...prev,\n        activeDrag: prev.activeDrag ? { ...prev.activeDrag, x, y } : null\n      }));\n\n      // Move element and update layout\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true, // isUserAction\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact layout - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  const onDragStop = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Final move\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true,\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact and finalize - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      isDraggingRef.current = false;\n\n      setDragState({\n        activeDrag: null,\n        oldDragItem: null,\n        oldLayout: null\n      });\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  // ============================================================================\n  // Resize Handlers\n  // ============================================================================\n\n  const onResizeStart = useCallback(\n    (itemId: string): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      setResizeState({\n        resizing: true,\n        oldResizeItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return item;\n    },\n    [layout]\n  );\n\n  const onResize = useCallback(\n    (itemId: string, w: number, h: number, x?: number, y?: number) => {\n      const newLayout = layout.map(item => {\n        if (item.i === itemId) {\n          const updated: LayoutItem = {\n            ...item,\n            w,\n            h\n          };\n          if (x !== undefined) (updated as Mutable<LayoutItem>).x = x;\n          if (y !== undefined) (updated as Mutable<LayoutItem>).y = y;\n          return updated;\n        }\n        return item;\n      });\n\n      // Correct bounds and compact - use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor]\n  );\n\n  const onResizeStop = useCallback(\n    (itemId: string, w: number, h: number) => {\n      // Apply final resize\n      onResize(itemId, w, h);\n\n      setResizeState({\n        resizing: false,\n        oldResizeItem: null,\n        oldLayout: null\n      });\n    },\n    [onResize]\n  );\n\n  // ============================================================================\n  // Drop Handlers\n  // ============================================================================\n\n  const onDropDragOver = useCallback(\n    (droppingItem: LayoutItem, position: DroppingPosition) => {\n      // Check if item already exists in layout\n      const existingItem = getLayoutItem(layout, droppingItem.i);\n\n      if (!existingItem) {\n        // Add dropping item to layout - use compactor.compact() (#2213)\n        const newLayout = [...layout, droppingItem];\n        const corrected = correctBounds(newLayout, { cols });\n        const compacted = compactor.compact(corrected, cols);\n        setLayoutState(compacted);\n      }\n\n      setDropState({\n        droppingDOMNode: null, // Will be set by component\n        droppingPosition: position\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  const onDropDragLeave = useCallback(() => {\n    // Remove dropping placeholder from layout\n    const newLayout = layout.filter(item => item.i !== \"__dropping-elem__\");\n    setLayoutState(newLayout);\n\n    setDropState({\n      droppingDOMNode: null,\n      droppingPosition: null\n    });\n  }, [layout]);\n\n  const onDrop = useCallback(\n    (droppingItem: LayoutItem) => {\n      // Replace placeholder with actual item\n      const newLayout = layout.map(item => {\n        if (item.i === \"__dropping-elem__\") {\n          return {\n            ...item,\n            i: droppingItem.i,\n            static: false\n          };\n        }\n        return item;\n      });\n\n      // Use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n\n      setDropState({\n        droppingDOMNode: null,\n        droppingPosition: null\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  // ============================================================================\n  // Computed Values\n  // ============================================================================\n\n  const containerHeight = useMemo(() => bottom(layout), [layout]);\n\n  const isInteracting =\n    dragState.activeDrag !== null ||\n    resizeState.resizing ||\n    dropState.droppingPosition !== null;\n\n  return {\n    layout,\n    setLayout,\n    dragState,\n    resizeState,\n    dropState,\n    onDragStart,\n    onDrag,\n    onDragStop,\n    onResizeStart,\n    onResize,\n    onResizeStop,\n    onDropDragOver,\n    onDropDragLeave,\n    onDrop,\n    containerHeight,\n    isInteracting,\n    compactor\n  };\n}\n\nexport default useGridLayout;\n", "/**\n * useResponsiveLayout hook\n *\n * Manages responsive breakpoints and layout generation for different screen sizes.\n * Extracts state management from ResponsiveReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  Breakpoint,\n  Breakpoints,\n  ResponsiveLayouts,\n  Compactor\n} from \"../../core/types.js\";\nimport { cloneLayout } from \"../../core/layout.js\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n  sortBreakpoints\n} from \"../../core/responsive.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Default breakpoint names */\nexport type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";\n\n/** Default breakpoint widths */\nexport const DEFAULT_BREAKPOINTS: Breakpoints<DefaultBreakpoints> = {\n  lg: 1200,\n  md: 996,\n  sm: 768,\n  xs: 480,\n  xxs: 0\n};\n\n/** Default column counts per breakpoint */\nexport const DEFAULT_COLS: Breakpoints<DefaultBreakpoints> = {\n  lg: 12,\n  md: 10,\n  sm: 6,\n  xs: 4,\n  xxs: 2\n};\n\nexport interface UseResponsiveLayoutOptions<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current container width */\n  width: number;\n  /** Breakpoint definitions (name â†’ min-width) */\n  breakpoints?: Breakpoints<B>;\n  /** Column counts per breakpoint */\n  cols?: Breakpoints<B>;\n  /** Layouts for each breakpoint */\n  layouts?: ResponsiveLayouts<B>;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n  /** Called when breakpoint changes */\n  onBreakpointChange?: (newBreakpoint: B, cols: number) => void;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout, layouts: ResponsiveLayouts<B>) => void;\n  /** Called when width changes */\n  onWidthChange?: (\n    width: number,\n    margin: readonly [number, number],\n    cols: number,\n    containerPadding: readonly [number, number] | null\n  ) => void;\n}\n\nexport interface UseResponsiveLayoutResult<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current layout for the active breakpoint */\n  layout: Layout;\n  /** All layouts by breakpoint */\n  layouts: ResponsiveLayouts<B>;\n  /** Current active breakpoint */\n  breakpoint: B;\n  /** Column count for the current breakpoint */\n  cols: number;\n  /** Update layouts for a specific breakpoint */\n  setLayoutForBreakpoint: (breakpoint: B, layout: Layout) => void;\n  /** Update all layouts */\n  setLayouts: (layouts: ResponsiveLayouts<B>) => void;\n  /** Sorted array of breakpoint names (smallest to largest) */\n  sortedBreakpoints: B[];\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing responsive grid layouts.\n *\n * Automatically selects the appropriate layout based on container width\n * and generates layouts for new breakpoints from existing ones.\n *\n * @example\n * ```tsx\n * function MyResponsiveGrid() {\n *   const { width, containerRef } = useContainerWidth();\n *   const { layout, breakpoint, cols } = useResponsiveLayout({\n *     width,\n *     layouts: {\n *       lg: [...],\n *       md: [...],\n *       sm: [...]\n *     }\n *   });\n *\n *   return (\n *     <div ref={containerRef}>\n *       <GridLayout\n *         width={width}\n *         cols={cols}\n *         layout={layout}\n *       />\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useResponsiveLayout<B extends Breakpoint = DefaultBreakpoints>(\n  options: UseResponsiveLayoutOptions<B>\n): UseResponsiveLayoutResult<B> {\n  const {\n    width,\n    breakpoints = DEFAULT_BREAKPOINTS as unknown as Breakpoints<B>,\n    cols: colsConfig = DEFAULT_COLS as unknown as Breakpoints<B>,\n    layouts: propsLayouts = {} as ResponsiveLayouts<B>,\n    compactor = verticalCompactor,\n    onBreakpointChange,\n    onLayoutChange,\n    onWidthChange\n  } = options;\n\n  // Sorted breakpoints for consistent ordering\n  const sortedBreakpoints = useMemo(\n    () => sortBreakpoints(breakpoints),\n    [breakpoints]\n  );\n\n  // Calculate initial breakpoint and cols\n  const initialBreakpoint = useMemo(\n    () => getBreakpointFromWidth(breakpoints, width),\n    // Only calculate on mount, not on width changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const initialCols = useMemo(\n    () => getColsFromBreakpoint(initialBreakpoint, colsConfig),\n    [initialBreakpoint, colsConfig]\n  );\n\n  // State\n  const [breakpoint, setBreakpoint] = useState<B>(initialBreakpoint);\n  const [cols, setCols] = useState<number>(initialCols);\n  const [layouts, setLayoutsState] = useState<ResponsiveLayouts<B>>(() => {\n    // Clone initial layouts\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of sortedBreakpoints) {\n      const layout = propsLayouts[bp];\n      if (layout) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layout);\n      }\n    }\n    return cloned;\n  });\n\n  // Track previous values for change detection\n  const prevWidthRef = useRef(width);\n  const prevBreakpointRef = useRef(breakpoint);\n  // Separate refs for props vs state to prevent infinite loops (#2202)\n  // When using inline objects for layouts prop, we need to compare props to props\n  // and state to state, not mix them up.\n  const prevPropsLayoutsRef = useRef(propsLayouts);\n  const prevLayoutsRef = useRef(layouts);\n\n  // Current layout for the active breakpoint - use compactor (#2213)\n  const layout = useMemo(() => {\n    return findOrGenerateResponsiveLayout(\n      layouts,\n      breakpoints,\n      breakpoint,\n      prevBreakpointRef.current,\n      cols,\n      compactor\n    );\n  }, [layouts, breakpoints, breakpoint, cols, compactor]);\n\n  // Set layout for a specific breakpoint\n  const setLayoutForBreakpoint = useCallback((bp: B, newLayout: Layout) => {\n    setLayoutsState((prev: ResponsiveLayouts<B>) => ({\n      ...prev,\n      [bp]: cloneLayout(newLayout)\n    }));\n  }, []);\n\n  // Set all layouts\n  const setLayouts = useCallback((newLayouts: ResponsiveLayouts<B>) => {\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of Object.keys(newLayouts) as B[]) {\n      const layoutForBp = newLayouts[bp];\n      if (layoutForBp) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layoutForBp);\n      }\n    }\n    setLayoutsState(cloned);\n  }, []);\n\n  // Handle width changes\n  useEffect(() => {\n    if (prevWidthRef.current === width) return;\n    prevWidthRef.current = width;\n\n    // Determine new breakpoint\n    const newBreakpoint = getBreakpointFromWidth(breakpoints, width);\n    const newCols = getColsFromBreakpoint(newBreakpoint, colsConfig);\n\n    // Notify width change\n    onWidthChange?.(width, [10, 10], newCols, null);\n\n    // Check if breakpoint changed\n    if (newBreakpoint !== breakpoint) {\n      // Generate layout for new breakpoint\n      // Use compactor (#2213)\n      const newLayout = findOrGenerateResponsiveLayout(\n        layouts,\n        breakpoints,\n        newBreakpoint,\n        breakpoint,\n        newCols,\n        compactor\n      );\n\n      // Update layouts with the new breakpoint layout\n      const updatedLayouts: ResponsiveLayouts<B> = {\n        ...layouts,\n        [newBreakpoint]: newLayout\n      };\n\n      setLayoutsState(updatedLayouts);\n      setBreakpoint(newBreakpoint);\n      setCols(newCols);\n\n      // Notify breakpoint change\n      onBreakpointChange?.(newBreakpoint, newCols);\n\n      prevBreakpointRef.current = newBreakpoint;\n    }\n  }, [\n    width,\n    breakpoints,\n    colsConfig,\n    breakpoint,\n    layouts,\n    compactor,\n    onBreakpointChange,\n    onWidthChange\n  ]);\n\n  // Sync with prop layouts when they change\n  useEffect(() => {\n    if (!deepEqual(propsLayouts, prevPropsLayoutsRef.current)) {\n      setLayouts(propsLayouts);\n      prevPropsLayoutsRef.current = propsLayouts;\n    }\n  }, [propsLayouts, setLayouts]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layouts, prevLayoutsRef.current)) {\n      prevLayoutsRef.current = layouts;\n      onLayoutChange?.(layout, layouts);\n    }\n  }, [layout, layouts, onLayoutChange]);\n\n  return {\n    layout,\n    layouts,\n    breakpoint,\n    cols,\n    setLayoutForBreakpoint,\n    setLayouts,\n    sortedBreakpoints\n  };\n}\n\nexport default useResponsiveLayout;\n"],
  "mappings": "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",
  "names": ["useRef", "useState", "useCallback", "useEffect", "useMemo", "layout", "deepEqual"]
}
