import {
  GridLayout,
  ResponsiveGridLayout,
  absoluteStrategy,
  containerBounds,
  createScaledStrategy,
  defaultConstraints,
  getCompactor,
  transformStrategy
} from "./chunk-QX5EKZXF.js";
import {
  require_jsx_runtime
} from "./chunk-CRNJR6QK.js";
import {
  clsx_default
} from "./chunk-VEB3A3D5.js";
import "./chunk-NHY3NUFE.js";
import "./chunk-276SZO74.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/react-grid-layout/dist/legacy.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function ReactGridLayout(props) {
  const {
    // Required
    children,
    width,
    // Grid measurement
    cols = 12,
    rowHeight = 150,
    maxRows = Infinity,
    margin = [10, 10],
    containerPadding = null,
    // Layout data
    layout,
    droppingItem,
    // Compaction
    compactType: compactTypeProp,
    preventCollision = false,
    allowOverlap = false,
    verticalCompact,
    // Drag behavior
    isDraggable = true,
    isBounded = false,
    draggableHandle,
    draggableCancel,
    // Resize behavior
    isResizable = true,
    resizeHandles = ["se"],
    resizeHandle,
    // Drop behavior
    isDroppable = false,
    // Position
    useCSSTransforms = true,
    transformScale = 1,
    // Container props
    autoSize,
    className,
    style,
    innerRef,
    // Callbacks
    onLayoutChange,
    onDragStart,
    onDrag,
    onDragStop,
    onResizeStart,
    onResize,
    onResizeStop,
    onDrop,
    onDropDragOver
  } = props;
  let compactType = compactTypeProp === void 0 ? "vertical" : compactTypeProp;
  if (verticalCompact === false) {
    if (true) {
      console.warn(
        '`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.'
      );
    }
    compactType = null;
  }
  const gridConfig = {
    cols,
    rowHeight,
    maxRows,
    margin,
    containerPadding
  };
  const dragConfig = {
    enabled: isDraggable,
    bounded: isBounded,
    handle: draggableHandle,
    cancel: draggableCancel,
    // Set threshold to 0 for backwards compatibility with v1 API
    // v2 API defaults to 3px threshold (fixes #1341, #1401)
    threshold: 0
  };
  const resizeConfig = {
    enabled: isResizable,
    handles: resizeHandles,
    handleComponent: resizeHandle
  };
  const dropConfig = {
    enabled: isDroppable
  };
  let positionStrategy;
  if (!useCSSTransforms) {
    positionStrategy = absoluteStrategy;
  } else if (transformScale !== 1) {
    positionStrategy = createScaledStrategy(transformScale);
  } else {
    positionStrategy = transformStrategy;
  }
  const compactor = getCompactor(compactType, allowOverlap, preventCollision);
  const constraints = isBounded ? [...defaultConstraints, containerBounds] : defaultConstraints;
  return (0, import_jsx_runtime.jsx)(
    GridLayout,
    {
      width,
      gridConfig,
      dragConfig,
      resizeConfig,
      dropConfig,
      positionStrategy,
      compactor,
      constraints,
      layout,
      droppingItem,
      autoSize,
      className,
      style,
      innerRef,
      onLayoutChange,
      onDragStart,
      onDrag,
      onDragStop,
      onResizeStart,
      onResize,
      onResizeStop,
      onDrop,
      onDropDragOver,
      children
    }
  );
}
ReactGridLayout.displayName = "ReactGridLayout";
var ReactGridLayout_default = ReactGridLayout;
function ResponsiveReactGridLayout(props) {
  const {
    // Required
    children,
    width,
    // Responsive-specific
    breakpoint,
    breakpoints,
    cols,
    layouts,
    onBreakpointChange,
    onLayoutChange,
    onWidthChange,
    // Grid measurement
    rowHeight,
    maxRows,
    margin,
    containerPadding,
    // Layout data
    droppingItem,
    // Compaction
    compactType: compactTypeProp,
    preventCollision = false,
    allowOverlap = false,
    verticalCompact,
    // Drag behavior
    isDraggable = true,
    isBounded = false,
    draggableHandle,
    draggableCancel,
    // Resize behavior
    isResizable = true,
    resizeHandles = ["se"],
    resizeHandle,
    // Drop behavior
    isDroppable = false,
    // Position
    useCSSTransforms = true,
    transformScale = 1,
    // Container props
    autoSize,
    className,
    style,
    innerRef,
    // Callbacks
    onDragStart,
    onDrag,
    onDragStop,
    onResizeStart,
    onResize,
    onResizeStop,
    onDrop,
    onDropDragOver
  } = props;
  let compactType = compactTypeProp === void 0 ? "vertical" : compactTypeProp;
  if (verticalCompact === false) {
    if (true) {
      console.warn(
        '`verticalCompact` on <ResponsiveReactGridLayout> is deprecated and will be removed soon. Use `compactType`: "horizontal" | "vertical" | null.'
      );
    }
    compactType = null;
  }
  const dragConfig = {
    enabled: isDraggable,
    bounded: isBounded,
    handle: draggableHandle,
    cancel: draggableCancel
  };
  const resizeConfig = {
    enabled: isResizable,
    handles: resizeHandles,
    handleComponent: resizeHandle
  };
  const dropConfig = {
    enabled: isDroppable
  };
  let positionStrategy;
  if (!useCSSTransforms) {
    positionStrategy = absoluteStrategy;
  } else if (transformScale !== 1) {
    positionStrategy = createScaledStrategy(transformScale);
  } else {
    positionStrategy = transformStrategy;
  }
  const compactor = getCompactor(compactType, allowOverlap, preventCollision);
  return (0, import_jsx_runtime.jsx)(
    ResponsiveGridLayout,
    {
      width,
      breakpoint,
      breakpoints,
      cols,
      layouts,
      rowHeight,
      maxRows,
      margin,
      containerPadding,
      compactor,
      dragConfig,
      resizeConfig,
      dropConfig,
      positionStrategy,
      droppingItem,
      autoSize,
      className,
      style,
      innerRef,
      onBreakpointChange,
      onLayoutChange,
      onWidthChange,
      onDragStart,
      onDrag,
      onDragStop,
      onResizeStart,
      onResize,
      onResizeStop,
      onDrop,
      onDropDragOver,
      children
    }
  );
}
ResponsiveReactGridLayout.displayName = "ResponsiveReactGridLayout";
var ResponsiveReactGridLayout_default = ResponsiveReactGridLayout;
var layoutClassName = "react-grid-layout";
function WidthProvider(ComposedComponent) {
  function WidthProviderWrapper(props) {
    const { measureBeforeMount = false, className, style, ...rest } = props;
    const [width, setWidth] = (0, import_react.useState)(1280);
    const [mounted, setMounted] = (0, import_react.useState)(false);
    const elementRef = (0, import_react.useRef)(null);
    const resizeObserverRef = (0, import_react.useRef)(null);
    (0, import_react.useEffect)(() => {
      setMounted(true);
    }, []);
    (0, import_react.useEffect)(() => {
      const node = elementRef.current;
      if (!(node instanceof HTMLElement)) return;
      const observer = new ResizeObserver((entries) => {
        if (entries[0]) {
          const newWidth = entries[0].contentRect.width;
          setWidth(newWidth);
        }
      });
      observer.observe(node);
      resizeObserverRef.current = observer;
      return () => {
        observer.unobserve(node);
        observer.disconnect();
      };
    }, [mounted]);
    if (measureBeforeMount && !mounted) {
      return (0, import_jsx_runtime.jsx)(
        "div",
        {
          className: clsx_default(className, layoutClassName),
          style,
          ref: elementRef
        }
      );
    }
    return (0, import_jsx_runtime.jsx)(
      ComposedComponent,
      {
        innerRef: elementRef,
        className,
        style,
        ...rest,
        width
      }
    );
  }
  WidthProviderWrapper.displayName = `WidthProvider(${ComposedComponent.displayName || ComposedComponent.name || "Component"})`;
  return WidthProviderWrapper;
}
export {
  ReactGridLayout,
  ResponsiveReactGridLayout_default as Responsive,
  ResponsiveReactGridLayout,
  WidthProvider,
  ReactGridLayout_default as default
};
//# sourceMappingURL=react-grid-layout_legacy.js.map
